CCS PCH C Compiler, Version 4.140, 21898               25-jul-13 15:48

               Filename:   E:\Eletronica\Projetos\Calendario\calendario.lst

               ROM used:   1368 bytes (4%)
                           Largest free fragment is 31400
               RAM used:   12 (1%) at main() level
                           21 (1%) worst case
               Stack:     2 locations

*
0000:  GOTO   029E
.................... ///* 
.................... // * calendario.c 
.................... // * 
.................... // *  Created on: 02/02/2012 
.................... // *      Author: cuki 
.................... // */ 
....................  
.................... #include<18F452.h>                  //Aqui é incluso o header (*.h)  para o microcontrolador utilizado. 
.................... //////// Standard Header file for the PIC18F452 device //////////////// 
.................... #device PIC18F452 
.................... #list 
....................  
.................... //#device ADC = 10                      //Define 10 bits para o resultado da conversão AD 
.................... #use delay (clock=8000000)	     //Aqui definimos a frequência do cristal para cálculo dos delays 
*
0278:  CLRF   FEA
027A:  MOVLW  0D
027C:  MOVWF  FE9
027E:  MOVF   FEF,W
0280:  BZ    029C
0282:  MOVLW  02
0284:  MOVWF  01
0286:  CLRF   00
0288:  DECFSZ 00,F
028A:  BRA    0288
028C:  DECFSZ 01,F
028E:  BRA    0286
0290:  MOVLW  97
0292:  MOVWF  00
0294:  DECFSZ 00,F
0296:  BRA    0294
0298:  DECFSZ FEF,F
029A:  BRA    0282
029C:  RETURN 0
.................... #fuses HS, NOWDT, PUT, BROWNOUT, NOLVP //Configuração dos fusíveis 
.................... #use rs232(baud=9600,xmit=PIN_C6,rcv=PIN_C7) 
.................... #include "ds1307.c" 
.................... /* 
....................  * ds1307.c 
....................  * 
....................  *  Created on: 03/02/2012 
....................  *      Author: cuki 
....................  */ 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... ///                               DS1307.C                                   /// 
.................... ///                     Driver for Real Time Clock                           /// 
.................... ///                                                                          /// 
.................... /// ds1307_init() - Enable oscillator without clearing the seconds register -/// 
.................... ///                 used when PIC loses power and DS1307 run from 3V BAT     /// 
.................... ///               - Disable squarewave output                                /// 
.................... ///                                                                          /// 
.................... /// conn_screw(day,mth,year,dow,hour,min,sec)  Set the date/time   /// 
.................... ///                                                                          /// 
.................... /// ds1307_get_date(day,mth,year,dow)               Get the date             /// 
.................... ///                                                                          /// 
.................... /// ds1307_get_time(hr,min,sec)                     Get the time             /// 
.................... ///                                                                          /// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #define RTC_SDA  PIN_C4 
.................... #define RTC_SCL  PIN_C3 
....................  
.................... #use i2c(master, sda=RTC_SDA, scl=RTC_SCL) 
*
0004:  MOVLW  08
0006:  MOVWF  01
0008:  BRA    000A
000A:  BCF    F8B.3
000C:  BCF    F94.3
000E:  BRA    0010
0010:  NOP   
0012:  RLCF   14,F
0014:  BCF    F8B.4
0016:  BTFSC  FD8.0
0018:  BSF    F94.4
001A:  BTFSS  FD8.0
001C:  BCF    F94.4
001E:  BSF    F94.3
0020:  BTFSS  F82.3
0022:  BRA    0020
0024:  DECFSZ 01,F
0026:  BRA    0008
0028:  BRA    002A
002A:  BCF    F8B.3
002C:  BCF    F94.3
002E:  NOP   
0030:  BSF    F94.4
0032:  BRA    0034
0034:  NOP   
0036:  BRA    0038
0038:  NOP   
003A:  BSF    F94.3
003C:  BTFSS  F82.3
003E:  BRA    003C
0040:  CLRF   01
0042:  BRA    0044
0044:  NOP   
0046:  BTFSC  F82.4
0048:  BSF    01.0
004A:  BCF    F8B.3
004C:  BCF    F94.3
004E:  BCF    F8B.4
0050:  BCF    F94.4
0052:  RETURN 0
0054:  MOVLW  08
0056:  MOVWF  11
0058:  MOVFF  00,12
005C:  BSF    F94.4
005E:  BRA    0060
0060:  NOP   
0062:  BSF    F94.3
0064:  BTFSS  F82.3
0066:  BRA    0064
0068:  BTFSC  F82.4
006A:  BSF    FD8.0
006C:  BTFSS  F82.4
006E:  BCF    FD8.0
0070:  RLCF   01,F
0072:  BRA    0074
0074:  BCF    F94.3
0076:  BCF    F8B.3
0078:  DECFSZ 11,F
007A:  BRA    005C
007C:  BSF    F94.4
007E:  BRA    0080
0080:  NOP   
0082:  BCF    F8B.4
0084:  MOVF   12,W
0086:  BTFSS  FD8.2
0088:  BCF    F94.4
008A:  NOP   
008C:  BSF    F94.3
008E:  BTFSS  F82.3
0090:  BRA    008E
0092:  BRA    0094
0094:  BCF    F8B.3
0096:  BCF    F94.3
0098:  BRA    009A
009A:  NOP   
009C:  BCF    F8B.4
009E:  BCF    F94.4
00A0:  RETURN 0
....................  
.................... BYTE bin2bcd(BYTE binary_value); 
.................... BYTE bcd2bin(BYTE bcd_value); 
....................  
.................... void ds1307_init(void) 
.................... { 
....................    BYTE seconds = 0; 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD0);      // WR to RTC 
....................    i2c_write(0x00);      // REG 0 
....................    i2c_start(); 
....................    i2c_write(0xD1);      // RD from RTC 
....................    seconds = bcd2bin(i2c_read(0)); // Read current "seconds" in DS1307 
....................    i2c_stop(); 
....................    seconds &= 0x7F; 
....................  
....................    delay_us(3); 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD0);      // WR to RTC 
....................    i2c_write(0x00);      // REG 0 
....................    i2c_write(bin2bcd(seconds));     // Start oscillator with current "seconds value 
....................    i2c_start(); 
....................    i2c_write(0xD0);      // WR to RTC 
....................    i2c_write(0x07);      // Control Register 
....................    i2c_write(0x10);     // Disable squarewave output pin 
....................    i2c_stop(); 
....................  
.................... } 
....................  
.................... void ds1307_set_date_time(BYTE day, BYTE mth, BYTE year, BYTE dow, BYTE hr, BYTE min, BYTE sec) 
.................... { 
....................   sec &= 0x7F; 
*
01C6:  BCF    12.7
....................   hr &= 0x3F; 
01C8:  MOVLW  3F
01CA:  ANDWF  10,F
....................  
....................   i2c_start(); 
01CC:  BSF    F94.4
01CE:  BRA    01D0
01D0:  BSF    F94.3
01D2:  BRA    01D4
01D4:  NOP   
01D6:  BCF    F8B.4
01D8:  BCF    F94.4
01DA:  BRA    01DC
01DC:  BCF    F8B.3
01DE:  BCF    F94.3
....................   i2c_write(0xD0);            // I2C write address 
01E0:  MOVLW  D0
01E2:  MOVWF  14
01E4:  RCALL  0004
....................   delay_us(1); 
01E6:  BRA    01E8
....................   i2c_write(0x00);            // Start at REG 0 - Seconds 
01E8:  CLRF   14
01EA:  RCALL  0004
....................   i2c_write(bin2bcd(sec));      // REG 0 
01EC:  MOVFF  12,13
01F0:  RCALL  01A2
01F2:  MOVFF  01,13
01F6:  MOVFF  01,14
01FA:  RCALL  0004
....................   i2c_write(bin2bcd(min));      // REG 1 
01FC:  MOVFF  11,13
0200:  RCALL  01A2
0202:  MOVFF  01,13
0206:  MOVFF  01,14
020A:  RCALL  0004
....................   i2c_write(bin2bcd(hr));      // REG 2 
020C:  MOVFF  10,13
0210:  RCALL  01A2
0212:  MOVFF  01,13
0216:  MOVFF  01,14
021A:  RCALL  0004
....................   i2c_write(bin2bcd(dow));      // REG 3 
021C:  MOVFF  0F,13
0220:  RCALL  01A2
0222:  MOVFF  01,13
0226:  MOVFF  01,14
022A:  RCALL  0004
....................   i2c_write(bin2bcd(day));      // REG 4 
022C:  MOVFF  0C,13
0230:  RCALL  01A2
0232:  MOVFF  01,13
0236:  MOVFF  01,14
023A:  RCALL  0004
....................   i2c_write(bin2bcd(mth));      // REG 5 
023C:  MOVFF  0D,13
0240:  RCALL  01A2
0242:  MOVFF  01,13
0246:  MOVFF  01,14
024A:  RCALL  0004
....................   i2c_write(bin2bcd(year));      // REG 6 
024C:  MOVFF  0E,13
0250:  RCALL  01A2
0252:  MOVFF  01,13
0256:  MOVFF  01,14
025A:  RCALL  0004
....................   //i2c_write(0x80);            // REG 7 - Disable squarewave output pin 
....................   i2c_write(0x10); 
025C:  MOVLW  10
025E:  MOVWF  14
0260:  RCALL  0004
....................   i2c_stop(); 
0262:  BCF    F94.4
0264:  NOP   
0266:  BSF    F94.3
0268:  BTFSS  F82.3
026A:  BRA    0268
026C:  BRA    026E
026E:  BRA    0270
0270:  NOP   
0272:  BSF    F94.4
0274:  BRA    0276
.................... } 
0276:  RETURN 0
....................  
.................... void ds1307_get_date(BYTE &day, BYTE &mth, BYTE &year, BYTE &dow) 
.................... { 
....................   i2c_start(); 
*
02BA:  BSF    F94.4
02BC:  BRA    02BE
02BE:  BSF    F94.3
02C0:  BRA    02C2
02C2:  NOP   
02C4:  BCF    F8B.4
02C6:  BCF    F94.4
02C8:  BRA    02CA
02CA:  BCF    F8B.3
02CC:  BCF    F94.3
....................   i2c_write(0xD0); 
02CE:  MOVLW  D0
02D0:  MOVWF  14
02D2:  RCALL  0004
....................   delay_us(1); 
02D4:  BRA    02D6
....................   i2c_write(0x03);            // Start at REG 3 - Day of week 
02D6:  MOVLW  03
02D8:  MOVWF  14
02DA:  RCALL  0004
....................   i2c_start(); 
02DC:  BSF    F94.4
02DE:  BRA    02E0
02E0:  BSF    F94.3
02E2:  BRA    02E4
02E4:  NOP   
02E6:  BTFSS  F82.3
02E8:  BRA    02E6
02EA:  BCF    F8B.4
02EC:  BCF    F94.4
02EE:  BRA    02F0
02F0:  BCF    F8B.3
02F2:  BCF    F94.3
....................   i2c_write(0xD1); 
02F4:  MOVLW  D1
02F6:  MOVWF  14
02F8:  RCALL  0004
....................   dow  = bcd2bin(i2c_read() & 0x7f);   // REG 3 
02FA:  MOVLW  01
02FC:  MOVWF  00
02FE:  RCALL  0054
0300:  MOVF   01,W
0302:  ANDLW  7F
0304:  MOVWF  0C
0306:  MOVWF  11
0308:  RCALL  00A2
030A:  MOVFF  01,0B
....................   day  = bcd2bin(i2c_read() & 0x3f);   // REG 4 
030E:  MOVLW  01
0310:  MOVWF  00
0312:  RCALL  0054
0314:  MOVF   01,W
0316:  ANDLW  3F
0318:  MOVWF  0C
031A:  MOVWF  11
031C:  RCALL  00A2
031E:  MOVFF  01,08
....................   mth  = bcd2bin(i2c_read() & 0x1f);   // REG 5 
0322:  MOVLW  01
0324:  MOVWF  00
0326:  RCALL  0054
0328:  MOVF   01,W
032A:  ANDLW  1F
032C:  MOVWF  0C
032E:  MOVWF  11
0330:  RCALL  00A2
0332:  MOVFF  01,09
....................   year = bcd2bin(i2c_read(0));            // REG 6 
0336:  CLRF   00
0338:  RCALL  0054
033A:  MOVFF  01,0C
033E:  MOVFF  01,11
0342:  RCALL  00A2
0344:  MOVFF  01,0A
....................   i2c_stop(); 
0348:  BCF    F94.4
034A:  NOP   
034C:  BSF    F94.3
034E:  BTFSS  F82.3
0350:  BRA    034E
0352:  BRA    0354
0354:  BRA    0356
0356:  NOP   
0358:  BSF    F94.4
035A:  BRA    035C
.................... } 
....................  
.................... void ds1307_get_time(BYTE &hr, BYTE &min, BYTE &sec) 
.................... { 
....................   i2c_start(); 
035C:  BSF    F94.4
035E:  BRA    0360
0360:  BSF    F94.3
0362:  BRA    0364
0364:  NOP   
0366:  BCF    F8B.4
0368:  BCF    F94.4
036A:  BRA    036C
036C:  BCF    F8B.3
036E:  BCF    F94.3
....................   i2c_write(0xD0); 
0370:  MOVLW  D0
0372:  MOVWF  14
0374:  RCALL  0004
....................   i2c_write(0x00);            // Start at REG 0 - Seconds 
0376:  CLRF   14
0378:  RCALL  0004
....................   i2c_start(); 
037A:  BSF    F94.4
037C:  BRA    037E
037E:  BSF    F94.3
0380:  BRA    0382
0382:  NOP   
0384:  BTFSS  F82.3
0386:  BRA    0384
0388:  BCF    F8B.4
038A:  BCF    F94.4
038C:  BRA    038E
038E:  BCF    F8B.3
0390:  BCF    F94.3
....................   i2c_write(0xD1); 
0392:  MOVLW  D1
0394:  MOVWF  14
0396:  RCALL  0004
....................   sec = bcd2bin(i2c_read() & 0x7f); 
0398:  MOVLW  01
039A:  MOVWF  00
039C:  RCALL  0054
039E:  MOVF   01,W
03A0:  ANDLW  7F
03A2:  MOVWF  0C
03A4:  MOVWF  11
03A6:  RCALL  00A2
03A8:  MOVFF  01,05
....................   min = bcd2bin(i2c_read() & 0x7f); 
03AC:  MOVLW  01
03AE:  MOVWF  00
03B0:  RCALL  0054
03B2:  MOVF   01,W
03B4:  ANDLW  7F
03B6:  MOVWF  0C
03B8:  MOVWF  11
03BA:  RCALL  00A2
03BC:  MOVFF  01,06
....................   hr  = bcd2bin(i2c_read(0) & 0x3f); 
03C0:  CLRF   00
03C2:  RCALL  0054
03C4:  MOVF   01,W
03C6:  ANDLW  3F
03C8:  MOVWF  0C
03CA:  MOVWF  11
03CC:  RCALL  00A2
03CE:  MOVFF  01,07
....................   i2c_stop(); 
03D2:  BCF    F94.4
03D4:  NOP   
03D6:  BSF    F94.3
03D8:  BTFSS  F82.3
03DA:  BRA    03D8
03DC:  BRA    03DE
03DE:  BRA    03E0
03E0:  NOP   
03E2:  BSF    F94.4
03E4:  BRA    03E6
....................  
.................... } 
....................  
.................... BYTE bin2bcd(BYTE binary_value) 
.................... { 
....................   BYTE temp; 
....................   BYTE retval; 
....................  
....................   temp = binary_value; 
*
01A2:  MOVFF  13,14
....................   retval = 0; 
01A6:  CLRF   15
....................  
....................   while(true) 
....................   { 
....................     // Get the tens digit by doing multiple subtraction 
....................     // of 10 from the binary value. 
....................     if(temp >= 10) 
01A8:  MOVF   14,W
01AA:  SUBLW  09
01AC:  BC    01B8
....................     { 
....................       temp -= 10; 
01AE:  MOVLW  0A
01B0:  SUBWF  14,F
....................       retval += 0x10; 
01B2:  MOVLW  10
01B4:  ADDWF  15,F
....................     } 
....................     else // Get the ones digit by adding the remainder. 
01B6:  BRA    01BE
....................     { 
....................       retval += temp; 
01B8:  MOVF   14,W
01BA:  ADDWF  15,F
....................       break; 
01BC:  BRA    01C0
....................     } 
....................   } 
01BE:  BRA    01A8
....................  
....................   return(retval); 
01C0:  MOVFF  15,01
.................... } 
01C4:  RETURN 0
....................  
....................  
.................... // Input range - 00 to 99. 
.................... BYTE bcd2bin(BYTE bcd_value) 
.................... { 
....................   BYTE temp; 
....................  
....................   temp = bcd_value; 
*
00A2:  MOVFF  11,12
....................   // Shifting upper digit right by 1 is same as multiplying by 8. 
....................   temp >>= 1; 
00A6:  BCF    FD8.0
00A8:  RRCF   12,F
....................   // Isolate the bits for the upper digit. 
....................   temp &= 0x78; 
00AA:  MOVLW  78
00AC:  ANDWF  12,F
....................  
....................   // Now return: (Tens * 8) + (Tens * 2) + Ones 
....................  
....................   return(temp + (temp >> 2) + (bcd_value & 0x0f)); 
00AE:  RRCF   12,W
00B0:  MOVWF  00
00B2:  RRCF   00,F
00B4:  MOVLW  3F
00B6:  ANDWF  00,F
00B8:  MOVF   00,W
00BA:  ADDWF  12,W
00BC:  MOVWF  13
00BE:  MOVF   11,W
00C0:  ANDLW  0F
00C2:  ADDWF  13,W
00C4:  MOVWF  01
.................... } 
00C6:  RETURN 0
....................  
.................... //#include "lcd_8b.c" 
....................  
.................... void main() { 
*
029E:  CLRF   FF8
02A0:  BCF    FD0.7
02A2:  CLRF   FEA
02A4:  CLRF   FE9
02A6:  MOVLW  0C
02A8:  MOVWF  FAF
02AA:  MOVLW  A2
02AC:  MOVWF  FAC
02AE:  MOVLW  90
02B0:  MOVWF  FAB
02B2:  BSF    FC1.0
02B4:  BSF    FC1.1
02B6:  BSF    FC1.2
02B8:  BCF    FC1.3
.................... 	BYTE sec; 
.................... 	BYTE min; 
.................... 	BYTE hrs; 
.................... 	BYTE day; 
.................... 	BYTE month; 
.................... 	BYTE yr; 
.................... 	BYTE dow; 
....................  
.................... //	ds1307_init(); 
....................  
.................... // Set date for -> 04 de abril de 2009 - Sábado 
.................... // Set time for -> 11:07:00 
.................... //ds1307_set_date_time(3, 2, 12, 6, 8, 54, 0); 
....................  
.................... 	while (true) { 
.................... 		ds1307_get_date(day, month, yr, dow); 
.................... 		ds1307_get_time(hrs, min, sec); 
....................  
.................... 		printf("\f%02d/\%02d/\%02d", day, month, yr); 
*
03E6:  MOVLW  0C
03E8:  BTFSS  F9E.4
03EA:  BRA    03E8
03EC:  MOVWF  FAD
03EE:  MOVFF  08,0C
03F2:  MOVLW  01
03F4:  MOVWF  0D
03F6:  RCALL  00F0
03F8:  MOVLW  2F
03FA:  BTFSS  F9E.4
03FC:  BRA    03FA
03FE:  MOVWF  FAD
0400:  MOVFF  09,0C
0404:  MOVLW  01
0406:  MOVWF  0D
0408:  RCALL  00F0
040A:  MOVLW  2F
040C:  BTFSS  F9E.4
040E:  BRA    040C
0410:  MOVWF  FAD
0412:  MOVFF  0A,0C
0416:  MOVLW  01
0418:  MOVWF  0D
041A:  RCALL  00F0
.................... 		printf("\n%02d:\%02d:\%02d", hrs, min, sec); 
041C:  MOVLW  0A
041E:  BTFSS  F9E.4
0420:  BRA    041E
0422:  MOVWF  FAD
0424:  MOVFF  07,0C
0428:  MOVLW  01
042A:  MOVWF  0D
042C:  RCALL  00F0
042E:  MOVLW  3A
0430:  BTFSS  F9E.4
0432:  BRA    0430
0434:  MOVWF  FAD
0436:  MOVFF  06,0C
043A:  MOVLW  01
043C:  MOVWF  0D
043E:  RCALL  00F0
0440:  MOVLW  3A
0442:  BTFSS  F9E.4
0444:  BRA    0442
0446:  MOVWF  FAD
0448:  MOVFF  05,0C
044C:  MOVLW  01
044E:  MOVWF  0D
0450:  RCALL  00F0
....................  
.................... 		if (!input(PIN_B0)) { 
0452:  BSF    F93.0
0454:  BTFSC  F81.0
0456:  BRA    0490
.................... 			day++; 
0458:  INCF   08,F
.................... 			if (day > 31) 
045A:  MOVF   08,W
045C:  SUBLW  1F
045E:  BC    0464
.................... 				day = 1; 
0460:  MOVLW  01
0462:  MOVWF  08
.................... 			ds1307_set_date_time(day, month, yr, dow, hrs, min, sec); 
0464:  MOVFF  08,0C
0468:  MOVFF  09,0D
046C:  MOVFF  0A,0E
0470:  MOVFF  0B,0F
0474:  MOVFF  07,10
0478:  MOVFF  06,11
047C:  MOVFF  05,12
0480:  RCALL  01C6
.................... 			delay_ms(300); 
0482:  MOVLW  02
0484:  MOVWF  0C
0486:  MOVLW  96
0488:  MOVWF  0D
048A:  RCALL  0278
048C:  DECFSZ 0C,F
048E:  BRA    0486
.................... 		} 
.................... 		if (!input(PIN_C0)) { 
0490:  BSF    F94.0
0492:  BTFSC  F82.0
0494:  BRA    04CE
.................... 			month++; 
0496:  INCF   09,F
.................... 			if (month > 12) 
0498:  MOVF   09,W
049A:  SUBLW  0C
049C:  BC    04A2
.................... 				month = 1; 
049E:  MOVLW  01
04A0:  MOVWF  09
.................... 			ds1307_set_date_time(day, month, yr, dow, hrs, min, sec); 
04A2:  MOVFF  08,0C
04A6:  MOVFF  09,0D
04AA:  MOVFF  0A,0E
04AE:  MOVFF  0B,0F
04B2:  MOVFF  07,10
04B6:  MOVFF  06,11
04BA:  MOVFF  05,12
04BE:  RCALL  01C6
.................... 			delay_ms(300); 
04C0:  MOVLW  02
04C2:  MOVWF  0C
04C4:  MOVLW  96
04C6:  MOVWF  0D
04C8:  RCALL  0278
04CA:  DECFSZ 0C,F
04CC:  BRA    04C4
.................... 		} 
.................... 		if (!input(PIN_B1)) { 
04CE:  BSF    F93.1
04D0:  BTFSC  F81.1
04D2:  BRA    050A
.................... 			hrs++; 
04D4:  INCF   07,F
.................... 			if (hrs > 23) 
04D6:  MOVF   07,W
04D8:  SUBLW  17
04DA:  BC    04DE
.................... 				hrs = 0; 
04DC:  CLRF   07
.................... 			ds1307_set_date_time(day, month, yr, dow, hrs, min, sec); 
04DE:  MOVFF  08,0C
04E2:  MOVFF  09,0D
04E6:  MOVFF  0A,0E
04EA:  MOVFF  0B,0F
04EE:  MOVFF  07,10
04F2:  MOVFF  06,11
04F6:  MOVFF  05,12
04FA:  RCALL  01C6
.................... 			delay_ms(300); 
04FC:  MOVLW  02
04FE:  MOVWF  0C
0500:  MOVLW  96
0502:  MOVWF  0D
0504:  RCALL  0278
0506:  DECFSZ 0C,F
0508:  BRA    0500
.................... 		} 
.................... 		if (!input(PIN_B2)) { 
050A:  BSF    F93.2
050C:  BTFSC  F81.2
050E:  BRA    0546
.................... 			min++; 
0510:  INCF   06,F
.................... 			if (min > 59) 
0512:  MOVF   06,W
0514:  SUBLW  3B
0516:  BC    051A
.................... 				min = 0; 
0518:  CLRF   06
.................... 			ds1307_set_date_time(day, month, yr, dow, hrs, min, sec); 
051A:  MOVFF  08,0C
051E:  MOVFF  09,0D
0522:  MOVFF  0A,0E
0526:  MOVFF  0B,0F
052A:  MOVFF  07,10
052E:  MOVFF  06,11
0532:  MOVFF  05,12
0536:  RCALL  01C6
.................... 			delay_ms(300); 
0538:  MOVLW  02
053A:  MOVWF  0C
053C:  MOVLW  96
053E:  MOVWF  0D
0540:  RCALL  0278
0542:  DECFSZ 0C,F
0544:  BRA    053C
.................... 		} 
.................... 		delay_ms(500); 
0546:  MOVLW  02
0548:  MOVWF  0C
054A:  MOVLW  FA
054C:  MOVWF  0D
054E:  RCALL  0278
0550:  DECFSZ 0C,F
0552:  BRA    054A
.................... 	} 
0554:  BRA    02BA
.................... } 
....................  
.................... //#include <18F452.h> 
.................... // 
.................... //#fuses hs 
.................... //#use delay (clock = 8MHz, RESTART_WDT) 
.................... //#use i2c (master,scl=pin_c3,sda=pin_c4,force_hw,fast = 100000) 
.................... // 
.................... //#include "lcd_8b.c" 
.................... ////#include "i2c.h" 
.................... //#include <stdlib.h> 
.................... // 
.................... //#define _SECONDS    0x00 
.................... //#define _MINUTES    0x01 
.................... //#define _HOURS    0x02 
.................... //#define _DAY      0x03 
.................... //#define _DATE    0x04 
.................... //#define _MONTH    0x05 
.................... //#define _YEAR    0x06 
.................... //#define _CONTROL    0x07 
.................... //#define _MODO12    0x00 
.................... //#define _MODO24    0x40 
.................... // 
.................... //void setMode(int modo); 
.................... //int make4(int var, int nibble); 
.................... //BYTE bin2bcd(BYTE binary_value); 
.................... //BYTE bcd2bin(BYTE bcd_value); 
.................... //void ds1307_set_date_time(BYTE day, BYTE mth, BYTE year, BYTE dow, BYTE hr, 
.................... //		BYTE min, BYTE sec); 
.................... // 
.................... //struct { 
.................... //	int seconds; 
.................... //	int minutes; 
.................... //	int hours; 
.................... //	int PM; 
.................... //	int modo24; 
.................... //	int day; 
.................... //	int date; 
.................... //	int month; 
.................... //	int year; 
.................... //	int sqwe_rs; 
.................... //} tempo; 
.................... // 
.................... //char semana[]; 
.................... //char modo[]; 
.................... // 
.................... //#INT_TIMER2 
.................... //void isr_timer2() { 
.................... //	register int cont; 
.................... //	register int aux; 
.................... // 
.................... //	i2c_start(); 
.................... //	i2c_write(0xD1); 
.................... //	i2c_write(0x00); 
.................... //	for (cont = 0x00; cont <= 0x07; ++cont) { 
.................... //		if (cont == 0x07) { 
.................... //			aux = i2c_read(0); 
.................... //			i2c_stop(); 
.................... //		} else 
.................... //			aux = i2c_read(); 
.................... //		if (aux != 0xFF) { 
.................... //			switch (aux) { 
.................... //			case _SECONDS: 
.................... //				tempo.seconds = make4(aux, 1) * 10 + make4(aux, 0); 
.................... //				break; 
.................... //			case _MINUTES: 
.................... //				tempo.minutes = 10 * make4(aux, 1) + make4(aux, 0); 
.................... //				break; 
.................... //			case _HOURS: 
.................... //				tempo.hours = make4(aux, 0); 
.................... //				if (bit_test(aux, 6)) { 
.................... //					tempo.hours += bit_test(aux, 4) * 10; 
.................... //					tempo.PM = bit_test(aux, 5); 
.................... //					tempo.modo24 = 0; 
.................... //				} else { 
.................... //					tempo.hours += (0x30 && make4(aux, 1)) * 10; 
.................... //					tempo.modo24 = 1; 
.................... //				} 
.................... //				break; 
.................... //			case _DAY: 
.................... //				tempo.day = make4(aux, 0); 
.................... //				break; 
.................... //			case _DATE: 
.................... //				tempo.date = make4(aux, 1) * 10 + make4(aux, 0); 
.................... //				break; 
.................... //			case _MONTH: 
.................... //				tempo.month = make4(aux, 1) * 10 + make4(aux, 0); 
.................... //				break; 
.................... //			case _YEAR: 
.................... //				tempo.year = make4(aux, 1) * 10 + make4(aux, 0); 
.................... //				break; 
.................... //			default: 
.................... //			} 
.................... //		} 
.................... //	} 
.................... //} 
.................... // 
.................... //void main(void) { 
.................... // 
.................... //	delay_ms(15); 
.................... //	lcd_init(); 
.................... // 
.................... //	setMode(_MODO24); 
.................... //	ds1307_set_date_time(04, 4, 9, 6, 11, 07, 00); 
.................... // 
.................... //	setup_timer_2(T2_DIV_BY_16, 255, 16); 
.................... //	enable_interrupts(INT_TIMER2); 
.................... ////	enable_interrupts(GLOBAL); 
.................... // 
.................... //	while (true) { 
.................... // 
.................... //		switch (tempo.day) { 
.................... //		case 0: 
.................... //			strcpy(semana, "DOM"); 
.................... //			break; 
.................... //		case 1: 
.................... //			strcpy(semana, "SEG"); 
.................... //			break; 
.................... //		case 2: 
.................... //			strcpy(semana, "TER"); 
.................... //			break; 
.................... //		case 3: 
.................... //			strcpy(semana, "QUA"); 
.................... //			break; 
.................... //		case 4: 
.................... //			strcpy(semana, "QUI"); 
.................... //			break; 
.................... //		case 5: 
.................... //			strcpy(semana, "SEX"); 
.................... //			break; 
.................... //		case 6: 
.................... //			strcpy(semana, "SAB"); 
.................... //			break; 
.................... //		default: 
.................... //			strcpy(semana, "NON"); 
.................... //		} 
.................... // 
.................... //		if (!tempo.modo24) { 
.................... //			if (tempo.PM) 
.................... //				strcpy(modo, "PM"); 
.................... //			else 
.................... //				strcpy(modo, "AM"); 
.................... //		} else { 
.................... //			strcpy(modo, "  "); 
.................... //		} 
.................... // 
.................... //		printf("\f%3s %02d/%02d/%04d", semana, tempo.date, tempo.month, 
.................... //				tempo.year); 
.................... //		printf("\n%2s %02d:%02d:%02d", modo, tempo.hours, tempo.minutes, 
.................... //				tempo.seconds); 
.................... //		delay_ms(500); 
.................... //	}//infinit loop 
.................... //}//this is the end, beautyfull friend, the end! 
.................... // 
.................... //void setMode(int mode) { 
.................... //	BYTE seconds = 0; 
.................... // 
.................... //	i2c_start(); 
.................... //	i2c_write(0xD0); // WR to RTC 
.................... //	i2c_write(0x00); // REG 0 
.................... //	i2c_start(); 
.................... //	i2c_write(0xD1); // RD from RTC 
.................... //	seconds = bcd2bin(i2c_read(0)); // Read current "seconds" in DS1307 
.................... //	i2c_stop(); 
.................... //	seconds &= 0x7F; 
.................... // 
.................... //	delay_us(3); 
.................... // 
.................... //	i2c_start(); 
.................... //	i2c_write(0xD0); // WR to RTC 
.................... //	i2c_write(0x00); // REG 0 
.................... //	i2c_write(bin2bcd(seconds)); // Start oscillator with current "seconds value 
.................... //	i2c_start(); 
.................... //	i2c_write(0xD0); // WR to RTC 
.................... //	i2c_write(0x07); // Control Register 
.................... //	i2c_write(0x10); // Disable squarewave output pin 
.................... //	i2c_stop(); 
.................... // 
.................... //} 
.................... // 
.................... //int make4(int var, int nibble) { 
.................... //	register int retorno; 
.................... // 
.................... //	if (nibble) 
.................... //		retorno = var >> 4; 
.................... //	else 
.................... //		retorno = var; 
.................... // 
.................... //	retorno &= 0x0F; 
.................... // 
.................... //	return retorno; 
.................... // 
.................... //} 
.................... // 
.................... //BYTE bin2bcd(BYTE binary_value) { 
.................... //	BYTE temp; 
.................... //	BYTE retval; 
.................... // 
.................... //	temp = binary_value; 
.................... //	retval = 0; 
.................... // 
.................... //	while (true) { 
.................... //		// Get the tens digit by doing multiple subtraction 
.................... //		// of 10 from the binary value. 
.................... //		if (temp >= 10) { 
.................... //			temp -= 10; 
.................... //			retval += 0x10; 
.................... //		} else // Get the ones digit by adding the remainder. 
.................... //		{ 
.................... //			retval += temp; 
.................... //			break; 
.................... //		} 
.................... //	} 
.................... // 
.................... //	return (retval); 
.................... //} 
.................... // 
.................... //BYTE bcd2bin(BYTE bcd_value) { 
.................... //	BYTE temp; 
.................... // 
.................... //	temp = bcd_value; 
.................... //	// Shifting upper digit right by 1 is same as multiplying by 8. 
.................... //	temp >>= 1; 
.................... //	// Isolate the bits for the upper digit. 
.................... //	temp &= 0x78; 
.................... // 
.................... //	// Now return: (Tens * 8) + (Tens * 2) + Ones 
.................... // 
.................... //	return (temp + (temp >> 2) + (bcd_value & 0x0f)); 
.................... //} 
.................... // 
.................... //void ds1307_set_date_time(BYTE day, BYTE mth, BYTE year, BYTE dow, BYTE hr, 
.................... //		BYTE min, BYTE sec) { 
.................... //	sec &= 0x7F; 
.................... //	hr &= 0x3F; 
.................... // 
.................... //	i2c_start(); 
.................... //	i2c_write(0xD0); // I2C write address 
.................... //	delay_us(1); 
.................... //	i2c_write(0x00); // Start at REG 0 - Seconds 
.................... //	i2c_write(bin2bcd(sec)); // REG 0 
.................... //	i2c_write(bin2bcd(min)); // REG 1 
.................... //	i2c_write(bin2bcd(hr)); // REG 2 
.................... //	i2c_write(bin2bcd(dow)); // REG 3 
.................... //	i2c_write(bin2bcd(day)); // REG 4 
.................... //	i2c_write(bin2bcd(mth)); // REG 5 
.................... //	i2c_write(bin2bcd(year)); // REG 6 
.................... //	//i2c_write(0x80);            // REG 7 - Disable squarewave output pin 
.................... //	i2c_write(0x10); 
.................... //	i2c_stop(); 
.................... //} 
.................... // 
.................... ////int addr[7]; 
.................... ////int cont = 0; 
.................... //// 
.................... ////i2c_start(); 
.................... ////i2c_write(0xD1); 
.................... ////i2c_write(0x00); 
.................... ////addr[0] = i2c_read(); 
.................... ////addr[1] = i2c_read(); 
.................... ////addr[2] = i2c_read(); 
.................... ////addr[3] = i2c_read(); 
.................... ////addr[4] = i2c_read(); 
.................... ////addr[5] = i2c_read(); 
.................... ////addr[6] = i2c_read(); 
.................... ////addr[7] = i2c_read(0); 
.................... ////i2c_stop(); 
.................... // 
.................... ////printf("\f"); 
.................... ////for (cont = 0; cont < 7; ++cont) { 
.................... ////	if (cont == 5) 
.................... ////		printf("\n"); 
.................... ////	printf("%x ", addr[cont]); 
.................... //// 
.................... ////} 
0556:  SLEEP 

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0E0E   PUT BROWNOUT BORV20 NOWDT WDT128
   Word  3: 0100   CCP2C1
   Word  4: 0081   STVREN NOLVP NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
